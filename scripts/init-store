#!/bin/bash

# This script's responsibility is to prepare the btrfs filesystem to be used
# with the groot-btrfs driver. It takes over the responsibility from the grootfs
# `init-store` command which is not part of the groot framework anymore.

set -e

# Help function
usage() {
cat <<-HELP
Usage: $(basename "${0}") [OPTIONS]

OPTIONS
-u      UID mapping for image translation (e.g. "<Namespace UID>:<Host UID>:<Size>;<Namespace UID>:<Host UID>:<Size>")
-g      GID mapping for image translation (e.g. "<Namespace UID>:<Host UID>:<Size>;<Namespace UID>:<Host UID>:<Size>")
-s      The path of the store to be created
-b      The filesystem size in bytes
-r      The user and group to look up in /etc/sub{u,g}id for UID/GID mappings, (e.g.: "<username>:<group>")
-h      Print this help message and exit
HELP
}

# This function checks $STORE_PATH for the following cases
# - If the path exists, it checks if it is a directory and a btrfs filesystem is mounted there.
#   If not, it fails with and error.
# - If the path does not exist, it creates it and mounts a btrfs filesystem.
prepare_filesystem() {
  if [ -d "${STORE_PATH}" ]; then
    validate_filesystem $STORE_PATH
  else
    create_and_mount_filesystem $STORE_PATH $STORE_SIZE_BYTES
  fi
}
validate_filesystem() {
  if [ $(stat -f -c "%T" "${1}") != "btrfs" ]; then
    echo "No btrfs filesystem on $1" && exit 1
  fi

  check_string=".*${1} btrfs .*user_subvol_rm_allowed.*"
  if [ $(cat /proc/mounts | grep "$check_string" | wc -c) -eq 0 ]; then
    echo "btrfs filesystem mounted without user_subvol_rm_allowed option" && exit 1
  fi
}

# Creates a btrfs filesystem and mounts it on $1. The size is defined by $2 in bytes.
create_and_mount_filesystem() {
  mkdir -p $1 -m 0755
  backing_store_file=$1/.backing-store
  touch $backing_store_file
  chmod 600 $backing_store_file
  truncate -s $2 $backing_store_file

  mkfs.btrfs -f $backing_store_file
  mount -t btrfs -o user_subvol_rm_allowed $backing_store_file $1
  btrfs quota enable $1
}

get_uid_mappings() {
  subuid_path="/etc/subuid"

  if [ -n "${UID_MAPPINGS}" ]; then
    echo '["'${UID_MAPPINGS//;/\",\"}'"]'
  else
    username=$(echo $ROOTLESS | cut -d: -f1)
    userid=$(id -u $username)
    result=$(get_subid_mapping $subuid_path $userid)

    echo '["'$userid':0:1","'$result'"]'
  fi
}

get_gid_mappings() {
  subgid_path="/etc/subgid"

  if [ -n "${GID_MAPPINGS}" ]; then
    echo '["'${GID_MAPPINGS//;/\",\"}'"]'
  elif [ -n "${ROOTLESS}" ]; then
    groupname=$(echo $ROOTLESS | cut -d: -f2)
    groupid=$(getent group $groupname | cut -d: -f3)
    result=$(get_subid_mapping $subgid_path $groupid)

    echo '["'$groupid':0:1","'$result'"]'
  else
    echo '[]'
  fi
}

# $1 is either /etc/subuid or /etc/subgid
# $2 is the {group,user} id
get_subid_mapping() {
  if [ -f ${1} ]; then
    host_id=$(cat ${1} | grep $2 | cut -d: -f2)
    size=$(cat ${1} | grep $2 | cut -d: -f3)
  fi

  echo "$host_id:1:$size"
}

apply_mappings() {
  uid_mappings=$(get_uid_mappings)
  gid_mappings=$(get_gid_mappings)
  namespace_file_path="${STORE_PATH}/meta/namespace.json"
  if [ ! -f "${namespace_file_path}" ]; then
    json='{"uid-mappings": '${uid_mappings}', "gid-mappings": '${gid_mappings}'}'
    echo $json > "${namespace_file_path}"
    chmod 755 "${namespace_file_path}"
  fi

  if [ $(cat "${namespace_file_path}" | grep -F "\"uid-mappings\": $uid_mappings" | wc -c) -eq 0 ]; then
    echo "provided UID mappings ($uid_mappings) do not match those already configured in the store"
    exit 1
  fi

  if [ $(cat "${namespace_file_path}" | grep -F "\"gid-mappings\": $gid_mappings" | wc -c) -eq 0 ]; then
    echo "provided GID mappings ($gid_mappings) do not match those already configured in the store"
    exit 1
  fi
}

chown_path() {
  chown_string=""
  owner_uid=$(get_uid_mappings | grep -Eo "[0-9]+:0:1+" | cut -d: -f2)
  if [ -n $owner_uid ]; then
    chown_string="${chown_string}${owner_uid}"
  fi
  owner_gid=$(get_gid_mappings | grep -Eo "[0-9]+:0:1+" | cut -d: -f2)
  if [ -n "${owner_gid}" ]; then
    echo "here $owner_gid"
    chown_string="${chown_string}:${owner_gid}"
  fi

  chown $chown_string $1
}

configure_store() {
  chmod 0700 $STORE_PATH
  dirs=("images" "volumes" "locks" "meta" "tmp" "meta/dependencies")
  for dir in "${dirs[@]}"; do
    dirpath="${STORE_PATH}/${dir}"
    if [ ! -d $dirpath ]; then
      mkdir -p $dirpath -m 0755
      chown_path $dirpath
    fi
  done
}

OPTIND=1         # Reset in case getopts has been used previously in the shell.

UID_MAPPINGS=""
GID_MAPPINGS=""
STORE_SIZE_BYTES=0
STORE_PATH=""
ROOTLESS=""

while getopts "hu:g:s:b:r:" opt; do
    case "$opt" in
    h)
        usage
        exit 0
        ;;
    u)
      UID_MAPPINGS=$OPTARG
      ;;
    g)
      GID_MAPPINGS=$OPTARG
      ;;
    s)
      STORE_PATH=$OPTARG
      ;;
    b)
      STORE_SIZE_BYTES=$OPTARG
      ;;
    r)
      ROOTLESS=$OPTARG
      ;;
    esac
done
shift $((OPTIND-1))
[ "${1:-}" = "--" ] && shift

if ([ -n "${UID_MAPPINGS}" ] || [ -n "${GID_MAPPINGS}" ]) && [ -n "${ROOTLESS}" ]; then
  echo "Can't specify both UID/GID mapping (-u, -g) and rootless (-r)"
  usage && exit 1;
fi

if [ -z "${STORE_PATH}" ]; then
  echo "Must specify store path (-s option)"
  usage && exit 1;
fi

if [ ${STORE_SIZE_BYTES} == 0 ]; then
  echo "Must specify store size (-b option)"
  usage && exit 1;
fi

if [ $(id -u) != 0 ]; then
  echo "Only Root user can initialize store" && exit 1
fi

prepare_filesystem
mkdir -p $STORE_PATH/meta
apply_mappings
chown_path $STORE_PATH
configure_store
