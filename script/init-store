#!/bin/bash

# This script's responsibility is to prepare the btrfs filesystem to be used
# with the groot-btrfs driver. It takes over the responsibility from the grootfs
# `init-store` command which is not part of the groot framework anymore.

# Help function
usage() {
cat <<-HELP
Usage: $(basename "${0}") [OPTIONS]

OPTIONS
-u      UID mapping for image translation (e.g. "<Namespace UID>:<Host UID>:<Size>")
-g      GID mapping for image translation (e.g. "<Namespace UID>:<Host UID>:<Size>")
-s      The path of the store to be created
-b      The filesystem size in bytes
-r      The user and group to look up in /etc/sub{u,g}id for UID/GID mappings, (e.g.: "<username>:<group>")
-h      Print this help message and exit
HELP
}

validate_filesystem() {
  if [ $(stat -f -c "%T" "${1}") != "btrfs" ]; then
    echo "No btrfs filesystem on $1" && exit 1
  fi

  check_string=".*${1} btrfs .*user_subvol_rm_allowed.*"
  if [ $(cat /proc/mounts | grep "$check_string" | wc -c) -eq 0 ]; then
    echo "btrfs filesystem mounted without user_subvol_rm_allowed option" && exit 1
  fi
}

create_and_mount_filesystem() {
  mkdir -p $STORE_PATH -m 0755
  backing_store_file=$STORE_PATH/.backing-store
  touch $backing_store_file
  chmod 600 $backing_store_file
  truncate -s $STORE_SIZE_BYTES $backing_store_file

  mount -t btrfs -o user_subvol_rm_allowed,rw,remount $backing_store_file $STORE_PATH
  mkfs.btrfs -f $backing_store_file
  mount -t btrfs -o user_subvol_rm_allowed $backing_store_file $STORE_PATH
}

get_uid_mappings() {
  subuid_path="/etc/subuid"

  if [ -n "${UID_MAPPINGS}" ]; then
    # TODO: Do we need to enable more than one `-u` and `-g` values (as in more mappings)?
    echo '["'${UID_MAPPINGS}'"]'
  else
    username=$(echo $ROOTLESS | cut -d: -f1)
    userid=$(id -u $username)
    result=$(get_subid_mapping $subuid_path $userid)

    echo '["'$userid':0:1","'$result'"]'
  fi
}

get_gid_mappings() {
  subgid_path="/etc/subgid"

  if [ -n "${GID_MAPPINGS}" ]; then
    echo '["'${GID_MAPPINGS}'"]'
  elif [ -n "${ROOTLESS}" ]; then
    groupname=$(echo $ROOTLESS | cut -d: -f2)
    groupid=$(getent group $groupname | cut -d: -f3)
    result=$(get_subid_mapping $subgid_path $groupid)

    echo '["'$groupid':0:1","'$result'"]'
  else
    echo '[]'
  fi
}

# $1 is either /etc/subuid or /etc/subgid
# $2 is the {group,user} id
get_subid_mapping() {
  if [ -f ${1} ]; then
    host_id=$(cat ${1} | grep $2 | cut -d: -f2)
    size=$(cat ${1} | grep $2 | cut -d: -f3)
  fi

  echo "$host_id:1:$size"
}

apply_mappings() {
  uid_mappings=$(get_uid_mappings)
  gid_mappings=$(get_gid_mappings)
  namespace_file_path="${STORE_PATH}/meta/namespace.json"
  if [ ! -f "${namespace_file_path}" ]; then
    json='{"uid-mappings": '${uid_mappings}', "gid-mappings": '${gid_mappings}'}'
    echo $json > "${namespace_file_path}"
    chmod 755 "${namespace_file_path}"
  fi

  if [ $(cat "${namespace_file_path}" | grep -F "\"uid-mappings\": $uid_mappings" | wc -c) -eq 0 ]; then
    echo "provided UID mappings ($uid_mappings) do not match those already configured in the store"
    exit 1
  fi

  if [ $(cat "${namespace_file_path}" | grep -F "\"gid-mappings\": $gid_mappings" | wc -c) -eq 0 ]; then
    echo "provided GID mappings ($gid_mappings) do not match those already configured in the store"
    exit 1
  fi
}

chown_path() {
  owner_uid=$(get_uid_mappings | grep -Eo "[0-9]+:0:1+" | cut -d: -f2)
  if [ -z $owner_uid ]; then
    owner_uid="-1"
  fi
  owner_gid=$(get_gid_mappings | grep -Eo "[0-9]+:0:1+" | cut -d: -f2)
  if [ -z $owner_gid ]; then
    owner_gid="-1"
  fi

  chown $owner_uid:$owner_gid $1
}

configure_store() {
  chmod 0700 $STORE_PATH
  dirs=("images" "volumes" "locks" "meta" "tmp" "meta/dependencies")
  for dir in "${dirs[@]}"; do
    dirpath="${STORE_PATH}/${dir}"
    if [ ! -d $dirpath ]; then
      mkdir -p $dirpath -m 0755
      chown_path $dirpath
    fi
  done
}

OPTIND=1         # Reset in case getopts has been used previously in the shell.

UID_MAPPINGS=""
GID_MAPPINGS=""
STORE_SIZE_BYTES=0
STORE_PATH=""
ROOTLESS=""

while getopts "hu:g:s:b:r:" opt; do
    case "$opt" in
    h)
        usage
        exit 0
        ;;
    u)
      UID_MAPPINGS=$OPTARG
      ;;
    g)
      GID_MAPPINGS=$OPTARG
      ;;
    s)
      STORE_PATH=$OPTARG
      ;;
    b)
      STORE_SIZE_BYTES=$OPTARG
      ;;
    r)
      ROOTLESS=$OPTARG
      ;;
    esac
done
shift $((OPTIND-1))
[ "${1:-}" = "--" ] && shift

if ([ -n "${UID_MAPPINGS}" ] || [ -n "${GID_MAPPINGS}" ]) && [ -n "${ROOTLESS}" ]; then
  echo "Can't specify both UID/GID mapping (-u, -g) and rootless (-r)"
  usage && exit 1;
fi

if [ -z "${STORE_PATH}" ]; then
  echo "Must specify store path (-s option)"
  usage && exit 1;
fi

if [ ${STORE_SIZE_BYTES} == 0 ]; then
  echo "Must specify store size (-b option)"
  usage && exit 1;
fi

if [ $(id -u) != 0 ]; then
  echo "Only Root user can initialize store" && exit 1
fi

if [ -d "${STORE_PATH}" ]; then
  echo "Store path already exists" && exit 1
fi

validate_filesystem $(readlink -f "${STORE_PATH}" | xargs dirname)
create_and_mount_filesystem
mkdir $STORE_PATH/meta
apply_mappings
chown_path $STORE_PATH
configure_store
