#!/bin/bash

# This script's responsibility is to prepare the btrfs filesystem to be used
# with the groot-btrfs driver. It takes over the responsibility from the grootfs
# `init-store` command which is not part of the groot framework anymore.

# Help function
usage() {
cat <<-HELP
Usage: $(basename "${0}") [OPTIONS]

OPTIONS
-u      UID mapping for image translation (e.g. "<Namespace UID>:<Host UID>:<Size>")
-g      GID mapping for image translation (e.g. "<Namespace UID>:<Host UID>:<Size>")
-s      The path of the store to be created
-b      The filesystem size in bytes
-r      The user and group to look up in /etc/sub{u,g}id for UID/GID mappings, (e.g.: "<username>:<group>")
-h      Print this help message and exit
HELP
}

validate_filesystem() {
  if [ $(stat -f -c "%T" "${1}") != "btrfs" ]; then
    echo "No btrfs filesystem on $1" && exit 1
  fi

  check_string=".*${1} btrfs .*user_subvol_rm_allowed.*"
  if [ $(cat /proc/mounts | grep "$check_string" | wc -c) -eq 0 ]; then
    echo "btrfs filesystem mounted without user_subvol_rm_allowed option" && exit 1
  fi
}

create_and_mount_filesystem() {
  mkdir -p $STORE_PATH -m 0755
  backing_store_file=$STORE_PATH/.backing-store
  touch $backing_store_file
  chmod 600 $backing_store_file
  truncate -s $STORE_SIZE_BYTES $backing_store_file

  mount -t btrfs -o user_subvol_rm_allowed,rw,remount $backing_store_file $STORE_PATH
  mkfs.btrfs -f $backing_store_file
  mount -t btrfs -o user_subvol_rm_allowed $backing_store_file $STORE_PATH
}

apply_mappings() {
  namespace_file_path="${STORE_PATH}/meta/namespace.json"
  if [ ! -f "${namespace_file_path}" ]; then
    json='{"uid-mappings": "'$UID_MAPPING'", "gid-mappings": "'$GID_MAPPING'"}'
    echo $json > "${namespace_file_path}"
    chmod 755 "${namespace_file_path}"
  fi

  if [ $(cat "${namespace_file_path}" | grep ".*\"uid-mappings\": \"$UID_MAPPING\".*" | wc -c) -eq 0 ]; then
    echo "provided UID mappings ($UID_MAPPING) do not match those already configured in the store"
    exit 1
  fi

  if [ $(cat "${namespace_file_path}" | grep ".*\"gid-mappings\": \"$GID_MAPPING\".*" | wc -c) -eq 0 ]; then
    echo "provided GID mappings ($GID_MAPPING) do not match those already configured in the store"
    exit 1
  fi
}

OPTIND=1         # Reset in case getopts has been used previously in the shell.

UID_MAPPING=""
GID_MAPPING=""
STORE_SIZE_BYTES=0
STORE_PATH=""
ROOTLESS=""

while getopts "hu:g:s:b:r:" opt; do
    case "$opt" in
    h)
        usage
        exit 0
        ;;
    u)
      UID_MAPPING=$OPTARG
      ;;
    g)
      GID_MAPPING=$OPTARG
      ;;
    s)
      STORE_PATH=$OPTARG
      ;;
    b)
      STORE_SIZE_BYTES=$OPTARG
      ;;
    r)
      ROOTLESS=$OPTARG
      ;;
    esac
done
shift $((OPTIND-1))
[ "${1:-}" = "--" ] && shift

if ([ -n "${UID_MAPPING}" ] || [ -n "${GID_MAPPING}" ]) && [ -n "${ROOTLESS}" ]; then
  echo "Can't specify both UID/GID mapping (-u, -g) and rootless (-r)"
  usage && exit 1;
fi

if [ -z "${STORE_PATH}" ]; then
  echo "Must specify store path (-s option)"
  usage && exit 1;
fi

if [ ${STORE_SIZE_BYTES} == 0 ]; then
  echo "Must specify store size (-b option)"
  usage && exit 1;
fi

if [ $(id -u) != 0 ]; then
  echo "Only Root user can initialize store" && exit 1
fi

if [ -d "${STORE_PATH}" ]; then
  echo "Store path already exists" && exit 1
fi

validate_filesystem $(readlink -f "${STORE_PATH}" | xargs dirname)
create_and_mount_filesystem
mkdir $STORE_PATH/meta
apply_mappings
