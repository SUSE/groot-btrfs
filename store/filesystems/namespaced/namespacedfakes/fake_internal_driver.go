// Code generated by counterfeiter. DO NOT EDIT.
package namespacedfakes

import (
	"sync"

	"code.cloudfoundry.org/lager"
	"github.com/SUSE/groot-btrfs/base_image_puller"
	"github.com/SUSE/groot-btrfs/groot"
	"github.com/SUSE/groot-btrfs/store/image_cloner"
)

type FakeInternalDriver struct {
	CreateVolumeStub        func(logger lager.Logger, parentID string, id string) (string, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		logger   lager.Logger
		parentID string
		id       string
	}
	createVolumeReturns struct {
		result1 string
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DestroyVolumeStub        func(logger lager.Logger, id string) error
	destroyVolumeMutex       sync.RWMutex
	destroyVolumeArgsForCall []struct {
		logger lager.Logger
		id     string
	}
	destroyVolumeReturns struct {
		result1 error
	}
	destroyVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	HandleOpaqueWhiteoutsStub        func(logger lager.Logger, id string, opaqueWhiteouts []string) error
	handleOpaqueWhiteoutsMutex       sync.RWMutex
	handleOpaqueWhiteoutsArgsForCall []struct {
		logger          lager.Logger
		id              string
		opaqueWhiteouts []string
	}
	handleOpaqueWhiteoutsReturns struct {
		result1 error
	}
	handleOpaqueWhiteoutsReturnsOnCall map[int]struct {
		result1 error
	}
	MoveVolumeStub        func(logger lager.Logger, from, to string) error
	moveVolumeMutex       sync.RWMutex
	moveVolumeArgsForCall []struct {
		logger lager.Logger
		from   string
		to     string
	}
	moveVolumeReturns struct {
		result1 error
	}
	moveVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	VolumePathStub        func(logger lager.Logger, id string) (string, error)
	volumePathMutex       sync.RWMutex
	volumePathArgsForCall []struct {
		logger lager.Logger
		id     string
	}
	volumePathReturns struct {
		result1 string
		result2 error
	}
	volumePathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	VolumesStub        func(logger lager.Logger) ([]string, error)
	volumesMutex       sync.RWMutex
	volumesArgsForCall []struct {
		logger lager.Logger
	}
	volumesReturns struct {
		result1 []string
		result2 error
	}
	volumesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	WriteVolumeMetaStub        func(logger lager.Logger, id string, data base_image_puller.VolumeMeta) error
	writeVolumeMetaMutex       sync.RWMutex
	writeVolumeMetaArgsForCall []struct {
		logger lager.Logger
		id     string
		data   base_image_puller.VolumeMeta
	}
	writeVolumeMetaReturns struct {
		result1 error
	}
	writeVolumeMetaReturnsOnCall map[int]struct {
		result1 error
	}
	CreateImageStub        func(logger lager.Logger, spec image_cloner.ImageDriverSpec) (groot.MountInfo, error)
	createImageMutex       sync.RWMutex
	createImageArgsForCall []struct {
		logger lager.Logger
		spec   image_cloner.ImageDriverSpec
	}
	createImageReturns struct {
		result1 groot.MountInfo
		result2 error
	}
	createImageReturnsOnCall map[int]struct {
		result1 groot.MountInfo
		result2 error
	}
	DestroyImageStub        func(logger lager.Logger, path string) error
	destroyImageMutex       sync.RWMutex
	destroyImageArgsForCall []struct {
		logger lager.Logger
		path   string
	}
	destroyImageReturns struct {
		result1 error
	}
	destroyImageReturnsOnCall map[int]struct {
		result1 error
	}
	FetchStatsStub        func(logger lager.Logger, path string) (groot.VolumeStats, error)
	fetchStatsMutex       sync.RWMutex
	fetchStatsArgsForCall []struct {
		logger lager.Logger
		path   string
	}
	fetchStatsReturns struct {
		result1 groot.VolumeStats
		result2 error
	}
	fetchStatsReturnsOnCall map[int]struct {
		result1 groot.VolumeStats
		result2 error
	}
	MarshalStub        func(logger lager.Logger) ([]byte, error)
	marshalMutex       sync.RWMutex
	marshalArgsForCall []struct {
		logger lager.Logger
	}
	marshalReturns struct {
		result1 []byte
		result2 error
	}
	marshalReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInternalDriver) CreateVolume(logger lager.Logger, parentID string, id string) (string, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		logger   lager.Logger
		parentID string
		id       string
	}{logger, parentID, id})
	fake.recordInvocation("CreateVolume", []interface{}{logger, parentID, id})
	fake.createVolumeMutex.Unlock()
	if fake.CreateVolumeStub != nil {
		return fake.CreateVolumeStub(logger, parentID, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createVolumeReturns.result1, fake.createVolumeReturns.result2
}

func (fake *FakeInternalDriver) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeInternalDriver) CreateVolumeArgsForCall(i int) (lager.Logger, string, string) {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return fake.createVolumeArgsForCall[i].logger, fake.createVolumeArgsForCall[i].parentID, fake.createVolumeArgsForCall[i].id
}

func (fake *FakeInternalDriver) CreateVolumeReturns(result1 string, result2 error) {
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) CreateVolumeReturnsOnCall(i int, result1 string, result2 error) {
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) DestroyVolume(logger lager.Logger, id string) error {
	fake.destroyVolumeMutex.Lock()
	ret, specificReturn := fake.destroyVolumeReturnsOnCall[len(fake.destroyVolumeArgsForCall)]
	fake.destroyVolumeArgsForCall = append(fake.destroyVolumeArgsForCall, struct {
		logger lager.Logger
		id     string
	}{logger, id})
	fake.recordInvocation("DestroyVolume", []interface{}{logger, id})
	fake.destroyVolumeMutex.Unlock()
	if fake.DestroyVolumeStub != nil {
		return fake.DestroyVolumeStub(logger, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyVolumeReturns.result1
}

func (fake *FakeInternalDriver) DestroyVolumeCallCount() int {
	fake.destroyVolumeMutex.RLock()
	defer fake.destroyVolumeMutex.RUnlock()
	return len(fake.destroyVolumeArgsForCall)
}

func (fake *FakeInternalDriver) DestroyVolumeArgsForCall(i int) (lager.Logger, string) {
	fake.destroyVolumeMutex.RLock()
	defer fake.destroyVolumeMutex.RUnlock()
	return fake.destroyVolumeArgsForCall[i].logger, fake.destroyVolumeArgsForCall[i].id
}

func (fake *FakeInternalDriver) DestroyVolumeReturns(result1 error) {
	fake.DestroyVolumeStub = nil
	fake.destroyVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) DestroyVolumeReturnsOnCall(i int, result1 error) {
	fake.DestroyVolumeStub = nil
	if fake.destroyVolumeReturnsOnCall == nil {
		fake.destroyVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) HandleOpaqueWhiteouts(logger lager.Logger, id string, opaqueWhiteouts []string) error {
	var opaqueWhiteoutsCopy []string
	if opaqueWhiteouts != nil {
		opaqueWhiteoutsCopy = make([]string, len(opaqueWhiteouts))
		copy(opaqueWhiteoutsCopy, opaqueWhiteouts)
	}
	fake.handleOpaqueWhiteoutsMutex.Lock()
	ret, specificReturn := fake.handleOpaqueWhiteoutsReturnsOnCall[len(fake.handleOpaqueWhiteoutsArgsForCall)]
	fake.handleOpaqueWhiteoutsArgsForCall = append(fake.handleOpaqueWhiteoutsArgsForCall, struct {
		logger          lager.Logger
		id              string
		opaqueWhiteouts []string
	}{logger, id, opaqueWhiteoutsCopy})
	fake.recordInvocation("HandleOpaqueWhiteouts", []interface{}{logger, id, opaqueWhiteoutsCopy})
	fake.handleOpaqueWhiteoutsMutex.Unlock()
	if fake.HandleOpaqueWhiteoutsStub != nil {
		return fake.HandleOpaqueWhiteoutsStub(logger, id, opaqueWhiteouts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.handleOpaqueWhiteoutsReturns.result1
}

func (fake *FakeInternalDriver) HandleOpaqueWhiteoutsCallCount() int {
	fake.handleOpaqueWhiteoutsMutex.RLock()
	defer fake.handleOpaqueWhiteoutsMutex.RUnlock()
	return len(fake.handleOpaqueWhiteoutsArgsForCall)
}

func (fake *FakeInternalDriver) HandleOpaqueWhiteoutsArgsForCall(i int) (lager.Logger, string, []string) {
	fake.handleOpaqueWhiteoutsMutex.RLock()
	defer fake.handleOpaqueWhiteoutsMutex.RUnlock()
	return fake.handleOpaqueWhiteoutsArgsForCall[i].logger, fake.handleOpaqueWhiteoutsArgsForCall[i].id, fake.handleOpaqueWhiteoutsArgsForCall[i].opaqueWhiteouts
}

func (fake *FakeInternalDriver) HandleOpaqueWhiteoutsReturns(result1 error) {
	fake.HandleOpaqueWhiteoutsStub = nil
	fake.handleOpaqueWhiteoutsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) HandleOpaqueWhiteoutsReturnsOnCall(i int, result1 error) {
	fake.HandleOpaqueWhiteoutsStub = nil
	if fake.handleOpaqueWhiteoutsReturnsOnCall == nil {
		fake.handleOpaqueWhiteoutsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.handleOpaqueWhiteoutsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) MoveVolume(logger lager.Logger, from string, to string) error {
	fake.moveVolumeMutex.Lock()
	ret, specificReturn := fake.moveVolumeReturnsOnCall[len(fake.moveVolumeArgsForCall)]
	fake.moveVolumeArgsForCall = append(fake.moveVolumeArgsForCall, struct {
		logger lager.Logger
		from   string
		to     string
	}{logger, from, to})
	fake.recordInvocation("MoveVolume", []interface{}{logger, from, to})
	fake.moveVolumeMutex.Unlock()
	if fake.MoveVolumeStub != nil {
		return fake.MoveVolumeStub(logger, from, to)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.moveVolumeReturns.result1
}

func (fake *FakeInternalDriver) MoveVolumeCallCount() int {
	fake.moveVolumeMutex.RLock()
	defer fake.moveVolumeMutex.RUnlock()
	return len(fake.moveVolumeArgsForCall)
}

func (fake *FakeInternalDriver) MoveVolumeArgsForCall(i int) (lager.Logger, string, string) {
	fake.moveVolumeMutex.RLock()
	defer fake.moveVolumeMutex.RUnlock()
	return fake.moveVolumeArgsForCall[i].logger, fake.moveVolumeArgsForCall[i].from, fake.moveVolumeArgsForCall[i].to
}

func (fake *FakeInternalDriver) MoveVolumeReturns(result1 error) {
	fake.MoveVolumeStub = nil
	fake.moveVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) MoveVolumeReturnsOnCall(i int, result1 error) {
	fake.MoveVolumeStub = nil
	if fake.moveVolumeReturnsOnCall == nil {
		fake.moveVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.moveVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) VolumePath(logger lager.Logger, id string) (string, error) {
	fake.volumePathMutex.Lock()
	ret, specificReturn := fake.volumePathReturnsOnCall[len(fake.volumePathArgsForCall)]
	fake.volumePathArgsForCall = append(fake.volumePathArgsForCall, struct {
		logger lager.Logger
		id     string
	}{logger, id})
	fake.recordInvocation("VolumePath", []interface{}{logger, id})
	fake.volumePathMutex.Unlock()
	if fake.VolumePathStub != nil {
		return fake.VolumePathStub(logger, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.volumePathReturns.result1, fake.volumePathReturns.result2
}

func (fake *FakeInternalDriver) VolumePathCallCount() int {
	fake.volumePathMutex.RLock()
	defer fake.volumePathMutex.RUnlock()
	return len(fake.volumePathArgsForCall)
}

func (fake *FakeInternalDriver) VolumePathArgsForCall(i int) (lager.Logger, string) {
	fake.volumePathMutex.RLock()
	defer fake.volumePathMutex.RUnlock()
	return fake.volumePathArgsForCall[i].logger, fake.volumePathArgsForCall[i].id
}

func (fake *FakeInternalDriver) VolumePathReturns(result1 string, result2 error) {
	fake.VolumePathStub = nil
	fake.volumePathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) VolumePathReturnsOnCall(i int, result1 string, result2 error) {
	fake.VolumePathStub = nil
	if fake.volumePathReturnsOnCall == nil {
		fake.volumePathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.volumePathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) Volumes(logger lager.Logger) ([]string, error) {
	fake.volumesMutex.Lock()
	ret, specificReturn := fake.volumesReturnsOnCall[len(fake.volumesArgsForCall)]
	fake.volumesArgsForCall = append(fake.volumesArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Volumes", []interface{}{logger})
	fake.volumesMutex.Unlock()
	if fake.VolumesStub != nil {
		return fake.VolumesStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.volumesReturns.result1, fake.volumesReturns.result2
}

func (fake *FakeInternalDriver) VolumesCallCount() int {
	fake.volumesMutex.RLock()
	defer fake.volumesMutex.RUnlock()
	return len(fake.volumesArgsForCall)
}

func (fake *FakeInternalDriver) VolumesArgsForCall(i int) lager.Logger {
	fake.volumesMutex.RLock()
	defer fake.volumesMutex.RUnlock()
	return fake.volumesArgsForCall[i].logger
}

func (fake *FakeInternalDriver) VolumesReturns(result1 []string, result2 error) {
	fake.VolumesStub = nil
	fake.volumesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) VolumesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.VolumesStub = nil
	if fake.volumesReturnsOnCall == nil {
		fake.volumesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.volumesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) WriteVolumeMeta(logger lager.Logger, id string, data base_image_puller.VolumeMeta) error {
	fake.writeVolumeMetaMutex.Lock()
	ret, specificReturn := fake.writeVolumeMetaReturnsOnCall[len(fake.writeVolumeMetaArgsForCall)]
	fake.writeVolumeMetaArgsForCall = append(fake.writeVolumeMetaArgsForCall, struct {
		logger lager.Logger
		id     string
		data   base_image_puller.VolumeMeta
	}{logger, id, data})
	fake.recordInvocation("WriteVolumeMeta", []interface{}{logger, id, data})
	fake.writeVolumeMetaMutex.Unlock()
	if fake.WriteVolumeMetaStub != nil {
		return fake.WriteVolumeMetaStub(logger, id, data)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.writeVolumeMetaReturns.result1
}

func (fake *FakeInternalDriver) WriteVolumeMetaCallCount() int {
	fake.writeVolumeMetaMutex.RLock()
	defer fake.writeVolumeMetaMutex.RUnlock()
	return len(fake.writeVolumeMetaArgsForCall)
}

func (fake *FakeInternalDriver) WriteVolumeMetaArgsForCall(i int) (lager.Logger, string, base_image_puller.VolumeMeta) {
	fake.writeVolumeMetaMutex.RLock()
	defer fake.writeVolumeMetaMutex.RUnlock()
	return fake.writeVolumeMetaArgsForCall[i].logger, fake.writeVolumeMetaArgsForCall[i].id, fake.writeVolumeMetaArgsForCall[i].data
}

func (fake *FakeInternalDriver) WriteVolumeMetaReturns(result1 error) {
	fake.WriteVolumeMetaStub = nil
	fake.writeVolumeMetaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) WriteVolumeMetaReturnsOnCall(i int, result1 error) {
	fake.WriteVolumeMetaStub = nil
	if fake.writeVolumeMetaReturnsOnCall == nil {
		fake.writeVolumeMetaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeVolumeMetaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) CreateImage(logger lager.Logger, spec image_cloner.ImageDriverSpec) (groot.MountInfo, error) {
	fake.createImageMutex.Lock()
	ret, specificReturn := fake.createImageReturnsOnCall[len(fake.createImageArgsForCall)]
	fake.createImageArgsForCall = append(fake.createImageArgsForCall, struct {
		logger lager.Logger
		spec   image_cloner.ImageDriverSpec
	}{logger, spec})
	fake.recordInvocation("CreateImage", []interface{}{logger, spec})
	fake.createImageMutex.Unlock()
	if fake.CreateImageStub != nil {
		return fake.CreateImageStub(logger, spec)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createImageReturns.result1, fake.createImageReturns.result2
}

func (fake *FakeInternalDriver) CreateImageCallCount() int {
	fake.createImageMutex.RLock()
	defer fake.createImageMutex.RUnlock()
	return len(fake.createImageArgsForCall)
}

func (fake *FakeInternalDriver) CreateImageArgsForCall(i int) (lager.Logger, image_cloner.ImageDriverSpec) {
	fake.createImageMutex.RLock()
	defer fake.createImageMutex.RUnlock()
	return fake.createImageArgsForCall[i].logger, fake.createImageArgsForCall[i].spec
}

func (fake *FakeInternalDriver) CreateImageReturns(result1 groot.MountInfo, result2 error) {
	fake.CreateImageStub = nil
	fake.createImageReturns = struct {
		result1 groot.MountInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) CreateImageReturnsOnCall(i int, result1 groot.MountInfo, result2 error) {
	fake.CreateImageStub = nil
	if fake.createImageReturnsOnCall == nil {
		fake.createImageReturnsOnCall = make(map[int]struct {
			result1 groot.MountInfo
			result2 error
		})
	}
	fake.createImageReturnsOnCall[i] = struct {
		result1 groot.MountInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) DestroyImage(logger lager.Logger, path string) error {
	fake.destroyImageMutex.Lock()
	ret, specificReturn := fake.destroyImageReturnsOnCall[len(fake.destroyImageArgsForCall)]
	fake.destroyImageArgsForCall = append(fake.destroyImageArgsForCall, struct {
		logger lager.Logger
		path   string
	}{logger, path})
	fake.recordInvocation("DestroyImage", []interface{}{logger, path})
	fake.destroyImageMutex.Unlock()
	if fake.DestroyImageStub != nil {
		return fake.DestroyImageStub(logger, path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyImageReturns.result1
}

func (fake *FakeInternalDriver) DestroyImageCallCount() int {
	fake.destroyImageMutex.RLock()
	defer fake.destroyImageMutex.RUnlock()
	return len(fake.destroyImageArgsForCall)
}

func (fake *FakeInternalDriver) DestroyImageArgsForCall(i int) (lager.Logger, string) {
	fake.destroyImageMutex.RLock()
	defer fake.destroyImageMutex.RUnlock()
	return fake.destroyImageArgsForCall[i].logger, fake.destroyImageArgsForCall[i].path
}

func (fake *FakeInternalDriver) DestroyImageReturns(result1 error) {
	fake.DestroyImageStub = nil
	fake.destroyImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) DestroyImageReturnsOnCall(i int, result1 error) {
	fake.DestroyImageStub = nil
	if fake.destroyImageReturnsOnCall == nil {
		fake.destroyImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalDriver) FetchStats(logger lager.Logger, path string) (groot.VolumeStats, error) {
	fake.fetchStatsMutex.Lock()
	ret, specificReturn := fake.fetchStatsReturnsOnCall[len(fake.fetchStatsArgsForCall)]
	fake.fetchStatsArgsForCall = append(fake.fetchStatsArgsForCall, struct {
		logger lager.Logger
		path   string
	}{logger, path})
	fake.recordInvocation("FetchStats", []interface{}{logger, path})
	fake.fetchStatsMutex.Unlock()
	if fake.FetchStatsStub != nil {
		return fake.FetchStatsStub(logger, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchStatsReturns.result1, fake.fetchStatsReturns.result2
}

func (fake *FakeInternalDriver) FetchStatsCallCount() int {
	fake.fetchStatsMutex.RLock()
	defer fake.fetchStatsMutex.RUnlock()
	return len(fake.fetchStatsArgsForCall)
}

func (fake *FakeInternalDriver) FetchStatsArgsForCall(i int) (lager.Logger, string) {
	fake.fetchStatsMutex.RLock()
	defer fake.fetchStatsMutex.RUnlock()
	return fake.fetchStatsArgsForCall[i].logger, fake.fetchStatsArgsForCall[i].path
}

func (fake *FakeInternalDriver) FetchStatsReturns(result1 groot.VolumeStats, result2 error) {
	fake.FetchStatsStub = nil
	fake.fetchStatsReturns = struct {
		result1 groot.VolumeStats
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) FetchStatsReturnsOnCall(i int, result1 groot.VolumeStats, result2 error) {
	fake.FetchStatsStub = nil
	if fake.fetchStatsReturnsOnCall == nil {
		fake.fetchStatsReturnsOnCall = make(map[int]struct {
			result1 groot.VolumeStats
			result2 error
		})
	}
	fake.fetchStatsReturnsOnCall[i] = struct {
		result1 groot.VolumeStats
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) Marshal(logger lager.Logger) ([]byte, error) {
	fake.marshalMutex.Lock()
	ret, specificReturn := fake.marshalReturnsOnCall[len(fake.marshalArgsForCall)]
	fake.marshalArgsForCall = append(fake.marshalArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Marshal", []interface{}{logger})
	fake.marshalMutex.Unlock()
	if fake.MarshalStub != nil {
		return fake.MarshalStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.marshalReturns.result1, fake.marshalReturns.result2
}

func (fake *FakeInternalDriver) MarshalCallCount() int {
	fake.marshalMutex.RLock()
	defer fake.marshalMutex.RUnlock()
	return len(fake.marshalArgsForCall)
}

func (fake *FakeInternalDriver) MarshalArgsForCall(i int) lager.Logger {
	fake.marshalMutex.RLock()
	defer fake.marshalMutex.RUnlock()
	return fake.marshalArgsForCall[i].logger
}

func (fake *FakeInternalDriver) MarshalReturns(result1 []byte, result2 error) {
	fake.MarshalStub = nil
	fake.marshalReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) MarshalReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.MarshalStub = nil
	if fake.marshalReturnsOnCall == nil {
		fake.marshalReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.marshalReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalDriver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.destroyVolumeMutex.RLock()
	defer fake.destroyVolumeMutex.RUnlock()
	fake.handleOpaqueWhiteoutsMutex.RLock()
	defer fake.handleOpaqueWhiteoutsMutex.RUnlock()
	fake.moveVolumeMutex.RLock()
	defer fake.moveVolumeMutex.RUnlock()
	fake.volumePathMutex.RLock()
	defer fake.volumePathMutex.RUnlock()
	fake.volumesMutex.RLock()
	defer fake.volumesMutex.RUnlock()
	fake.writeVolumeMetaMutex.RLock()
	defer fake.writeVolumeMetaMutex.RUnlock()
	fake.createImageMutex.RLock()
	defer fake.createImageMutex.RUnlock()
	fake.destroyImageMutex.RLock()
	defer fake.destroyImageMutex.RUnlock()
	fake.fetchStatsMutex.RLock()
	defer fake.fetchStatsMutex.RUnlock()
	fake.marshalMutex.RLock()
	defer fake.marshalMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInternalDriver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
